.equ PORTB, 0x6000
.equ PORTA, 0x6001
.equ DDRB,  0x6002
.equ DDRA,  0x6003

; cold boot 
.equ COLDBOOTADDR, 0x0200
.equ COLDBOOT1, 0x65
.equ RESETS, 0x201

.equ TEMP, 0x0210 ; 16 bytes of temporary 'registers'

; display
.equ RS, 0b00000010
.equ RW, 0b00000100 ; low on write
.equ E,  0b00001000

.org 0xFF00
; strings here

.org 0x8000

init:
	; setup the VIA chip
	LDA #0xff
	STA DDRA
	STA DDRB
	
	; check for cold boot (0x0200 should have 0x65, 0x02)
	LDA COLDBOOTADDR
	CMP #COLDBOOT1
	BEQ warmboot

coldboot:
	; set memory so that future resets will be warmboots
	LDA #COLDBOOT1
	STA COLDBOOTADDR
	
	; set resets 
	LDA #0xff
	STA RESETS
	
	; prompt the LCD to know we need to be in 4-bit mode.
	; function set
	LDA #0b00100000 ; 4 bit mode, 2 lines of text, 8x5 chars
	STA PORTB
	LDA #0b00101000 
	STA PORTB
	LDA #0b00100000 ; 4 bit mode, 2 lines of text, 8x5 chars
	STA PORTB
	
	; now we fall into warmboot.
warmboot:
	; increment reset counter
	INC RESETS
	
	
	; function set
	LDA #0b00101000 ; 4 bit mode, 2 lines of text, 8x5 chars
	JSR f_SendLcdInstruction
	
	; Display on/off Control
	LDA #0b00001110 ; Display on, cursor on, blink on
	JSR f_SendLcdInstruction
	
	; Entry mode set
	LDA #0b00000110 ; Increment for next char, do not scroll.
	JSR f_SendLcdInstruction
	
	; Clear Display
	LDA #0b00000001 ; 
	JSR f_SendLcdInstruction
	
	; Return home
	LDA #0b00000010 ; 
	JSR f_SendLcdInstruction
	
	; Start sending data

main:
	LDA #0x00
	
loop:	
	PHA
	JSR f_printByte
	; return home
	LDA #0b00000010 ; 
	JSR f_SendLcdInstruction
	PLA
	STA PORTA
	ADC #0x01
	BRA loop
	
end:
	BRA end



f_printByte:
	; prints a byte in hex on the display
	; A - byte
	; clobbers registers, TEMP 0-3
	
	TAY
	; get high nybble first
	AND #0b11110000
	LSR A
	LSR A
	LSR A
	LSR A
	JSR f_NybbleToChar
	STA TEMP + 1
	; low nybble
	TYA
	AND #0b00001111
	JSR f_NybbleToChar
	STA TEMP + 2
	
	; add a '\0' to the string
	LDA #0x00
	STA TEMP + 3
	LDA #<(TEMP+1)
	STA 0x00
	LDA #>(TEMP+1)
	STA 0x01
	JSR f_PrintString
	
	
	

f_NybbleToChar:
	; converts the value in A (0-15) to it's corresponding Hexidecimal digit
	CMP #0xA
	BCS NybbleToChar_letter
	; number
	ADC #0x30
	RTS
NybbleToChar_letter:
	ADC #0x36
	RTS

	
f_PrintString:
	; 0000, 0001 - address of string
	; string must fit within page.
	; clobbers A, X, TEMP0
	LDY #0
printString_loop:
	; stash Y on the stack
	TYA
	PHA
	
	LDA (0x00), Y ; load a pointer in the zero page plus Y.
	BEQ printString_end
	JSR f_SendLcdChar
	
	; take Y off the stack and increment
	PLA
	TAY
	INY
	BRA printString_loop

printString_end:
	PLA ; clean up the stack
	RTS
	


f_SendLcdInstruction: 
	; A - the instruction to send
	; clobbers A, X, TEMP0
	TAX
	; get the high nybble (to send first)
	AND #0xF0
	
	; send
	STA PORTB
	LDA #E
	JSR f_SetLcdControl
	LDA #0
	JSR f_SetLcdControl

	; get the low nybble
	TXA
	AND #0x0F
	; bitshift << 4
	ASL A
	ASL A
	ASL A
	ASL A
	
	; send
	STA PORTB
	LDA #E
	JSR f_SetLcdControl
	LDA #0
	JSR f_SetLcdControl
	
	RTS

	
f_SendLcdChar: 
	; A - the instruction to send
	; destroys All
	TAX
	; get the high nybble (to send first)
	AND #0xF0
	; send
	STA PORTB
	LDA #RS
	JSR f_SetLcdControl
	LDA #RS|E
	JSR f_SetLcdControl
	LDA #RS
	JSR f_SetLcdControl
		
	; get the low nybble
	TXA
	AND #0x0F
	; bitshift << 4
	ASL A
	ASL A
	ASL A
	ASL A
	
	; send
	JSR f_SetLcdData
	LDA #RS|E
	JSR f_SetLcdControl
	LDA #RS
	JSR f_SetLcdControl
	
	RTS
	
f_SetLcdData:
	; A - high nybble contains data to send, low nybble is zero.
	; clobbers A, TEMP0
	STA TEMP
	
	; grab the low nybble of PORTB
	LDA #0b00001111
	AND PORTB
	
	; now or Y and A together to merge them
	ORA TEMP
	
	; A should now store what we want to have in port B!
	STA PORTB
	RTS

f_SetLcdControl:
	; A - low nybble contains control lines to update, high nybble is zero.
	; clobbers A, TEMP0
	STA TEMP
	
	; grab the low nybble of PORTB
	LDA #0b11110000
	AND PORTB
	
	; now or Y and A together to merge them
	ORA TEMP
	
	; A should now store what we want to have in port B!
	STA PORTB
	RTS

.org 0xfffc
	; reset vector
.byte 0x00, 0x80, 0x00, 0x00
